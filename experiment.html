<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AIMless ‚Ä¢ P2P Chat + Provably-Fair Blackjack</title>
<style>
  :root { --bg:#0b0b0f; --panel:#16161d; --ink:#eaeaf2; --muted:#a7a7b3; --accent:#9b5cff; --accent2:#b47dff; }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 600px at 10% 0%, #141421 0%, var(--bg) 60%);color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:18px;display:flex;justify-content:center}
  .wrap{width:100%;max-width:1100px;display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid #222231;border-radius:14px;padding:14px}
  .wide{grid-column:1 / -1}
  h1{margin:0 0 8px;font-size:18px}
  h2{margin:0 0 10px;font-size:15px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#0b0b0f;border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn:hover{background:var(--accent2)}
  .btn.secondary{background:#2a2a38;color:var(--ink);border:1px solid #333349}
  .btn.danger{background:#ff5757;color:#0b0b0f}
  textarea,input{width:100%;background:#0f0f16;color:var(--ink);border:1px solid #282838;border-radius:8px;padding:10px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24243a;color:var(--ink);font-size:12px}
  .ok{background:#1d3d23;color:#7dff8b}.warn{background:#3d3d1d;color:#ffe57d}.bad{background:#3d1d1d;color:#ff7d7d}
  .chat{height:320px;overflow:auto;border:1px solid #242436;border-radius:10px;background:#0f0f16;padding:10px}
  .msg{margin:6px 0}
  .me .bubble{background:#7b61ff;color:#fff}
  .peer .bubble{background:#202437}
  .bubble{display:inline-block;padding:8px 12px;border-radius:14px;max-width:70%;word-wrap:break-word}
  .status{margin-top:8px}
  /* blackjack */
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .hand{min-height:64px;padding:8px;border:1px solid #242436;border-radius:10px;background:#0f0f16}
  .cardtag{display:inline-block;margin:4px 6px 0 0;padding:4px 6px;border-radius:8px;background:#202437}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <!-- Signaling -->
  <div class="card">
    <h1>üó®Ô∏è AIMless ‚Äî P2P Chat</h1>
    <h2>1) Role</h2>
    <div class="row">
      <label><input type="radio" name="role" value="host" checked> Host (Dealer)</label>
      <label><input type="radio" name="role" value="peer"> Peer (Player)</label>
      <span id="pcState" class="pill">idle</span>
      <span id="iceState" class="pill">idle</span>
      <span id="dcState" class="pill">chat: idle</span>
      <span id="bjState" class="pill">blackjack: idle</span>
    </div>

    <h2>2) Signaling (copy/paste blob)</h2>
    <div class="row">
      <button id="btnCreate" class="btn">Create Offer/Answer</button>
      <button id="btnCopy" class="btn secondary">üìã Copy</button>
      <button id="btnReset" class="btn danger">Reset</button>
    </div>

    <label class="mono" style="margin-top:8px">Your description (Base64)</label>
    <textarea id="local" rows="6" class="mono" readonly placeholder="Your Base64 blob will appear here‚Ä¶"></textarea>

    <label class="mono" style="margin-top:8px">Peer description (Base64 / JSON / raw SDP)</label>
    <textarea id="remote" rows="6" class="mono" placeholder="Paste the other side‚Äôs blob here‚Ä¶"></textarea>
    <div class="row" style="margin-top:8px">
      <button id="btnSetRemote" class="btn">Set Remote</button>
      <span id="status" class="status"></span>
    </div>
  </div>

  <!-- Chat -->
  <div class="card">
    <h2>3) Chat</h2>
    <div class="row">
      <input id="name" placeholder="Your name (optional)">
    </div>
    <div id="chat" class="chat"></div>
    <div class="row" style="margin-top:8px">
      <input id="msg" placeholder="Type a message‚Ä¶" disabled>
      <button id="send" class="btn" disabled>Send</button>
    </div>
  </div>

  <!-- Blackjack -->
  <div class="card wide">
    <h2>4) Blackjack (provably fair)</h2>
    <div class="row">
      <button id="bjNew" class="btn" disabled>New Hand (Dealer)</button>
      <button id="bjJoin" class="btn secondary" disabled>Join Hand (Player)</button>
      <button id="bjHit" class="btn secondary" disabled>Hit</button>
      <button id="bjStand" class="btn secondary" disabled>Stand</button>
      <button id="bjReveal" class="btn danger" disabled>Force Reveal</button>
    </div>

    <div class="grid2" style="margin-top:10px">
      <div>
        <div class="small mono">Dealer commit (SHA-256 of serverSeed)</div>
        <div id="bjCommit" class="mono small">‚Äì</div>
      </div>
      <div>
        <div class="small mono">Reveal (serverSeed ‚Üí verify)</div>
        <div id="bjRevealOut" class="mono small">‚Äì</div>
      </div>
    </div>

    <div class="grid2" style="margin-top:10px">
      <div>
        <div class="small mono">Your seed (clientSeed)</div>
        <div id="bjClientSeed" class="mono small">‚Äì</div>
      </div>
      <div>
        <div class="small mono">Fairness</div>
        <div id="bjFair" class="mono small">‚Äì</div>
      </div>
    </div>

    <div class="grid2" style="margin-top:10px">
      <div>
        <div class="small">Dealer hand <span id="bjDealerVal" class="mono small"></span></div>
        <div id="bjDealer" class="hand"></div>
      </div>
      <div>
        <div class="small">Player hand <span id="bjPlayerVal" class="mono small"></span></div>
        <div id="bjPlayer" class="hand"></div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <span id="bjStatus" class="status mono"></span>
    </div>
  </div>
</div>

<script>
/* ---------- shorthands ---------- */
const $ = id => document.getElementById(id);
const roleInputs = document.querySelectorAll('input[name="role"]');

/* ---------- state ---------- */
let role = 'host';            // 'host' = Dealer, 'peer' = Player
let pc, dcChat, dcBJ;

/* ---------- config ---------- */
const rtcConfig = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" }
  ],
  iceCandidatePoolSize: 10
};

/* ---------- ui helpers ---------- */
function pill(el, text, cls=""){ el.textContent=text; el.className="pill "+cls; }
function setStatus(t,c){ $('status').textContent=t; $('status').style.color=c||""; }
function addMsg(name, text, mine=false){
  const div=document.createElement('div'); div.className='msg '+(mine?'me':'peer');
  const b=document.createElement('div'); b.className='bubble'; b.textContent=(name?name+': ':'')+text;
  div.appendChild(b); $('chat').appendChild(div); $('chat').scrollTop=$('chat').scrollHeight;
}
function enableChat(on){ $('msg').disabled=!on; $('send').disabled=!on; }

/* ---------- robust blob handling ---------- */
function pack(desc){ return btoa(unescape(encodeURIComponent(JSON.stringify(desc)))); }
function unpackBase64(b64){ return JSON.parse(decodeURIComponent(escape(atob(b64)))); }
function looksLikeJson(s){ return /^\s*\{/.test((s||'').trim()); }
function looksLikeSdp(s){ return /^\s*v=0\s*/.test((s||'').trim()); }

/* ---------- peer connection ---------- */
function setupPC(){
  if(pc){ try{pc.close();}catch{} }
  pc = new RTCPeerConnection(rtcConfig);

  pc.onconnectionstatechange = () => {
    const s = pc.connectionState;
    pill($('pcState'), s, s==='connected'?'ok':(s==='failed'||s==='closed'?'bad':'warn'));
    if (s==='connected' || s==='completed') { enableChat(true); setStatus('PC connected ‚úì','#7dff8b'); }
    if (s==='disconnected'||s==='failed'||s==='closed'){ enableChat(false); }
  };

  pc.oniceconnectionstatechange = () => {
    const s = pc.iceConnectionState;
    pill($('iceState'), s, (s==='connected'||s==='completed')?'ok':(s==='failed'?'bad':'warn'));
  };

  // Update Base64 localDescription after brief ICE gather (non-trickle-ish)
  let gatherTimer=null;
  pc.onicecandidate = () => {
    if (gatherTimer) clearTimeout(gatherTimer);
    gatherTimer = setTimeout(() => {
      if (pc.localDescription) $('local').value = pack(pc.localDescription);
    }, 300);
  };

  if (role==='host') {
    // Chat channel (reliable, ordered)
    dcChat = pc.createDataChannel('chat',{ordered:true});
    wireChat(dcChat);
    // Blackjack channel (ordered/reliable; turn-based)
    dcBJ = pc.createDataChannel('blackjack',{ordered:true});
    wireBJ(dcBJ);
  } else {
    pc.ondatachannel = (ev)=>{
      const ch = ev.channel;
      if (ch.label === 'chat'){ dcChat = ch; wireChat(dcChat); }
      if (ch.label === 'blackjack'){ dcBJ = ch; wireBJ(dcBJ); }
    };
  }
}

function wireChat(channel){
  pill($('dcState'),'chat: connecting','warn');
  channel.onopen=()=>{ pill($('dcState'),'chat: open','ok'); enableChat(true); $('msg').focus(); setStatus('DataChannel open ‚úì','#7dff8b'); };
  channel.onclose=()=>{ pill($('dcState'),'chat: closed','bad'); enableChat(false); };
  channel.onerror=(e)=>{ pill($('dcState'),'chat: error','bad'); console.error('Chat DC error:',e); };
  channel.onmessage=(ev)=>{ try{ const {name,text}=JSON.parse(ev.data); addMsg(name||'Peer', text, false); }catch{ addMsg('Peer', String(ev.data), false); } };
}

/* ---------- actions ---------- */
async function createLocal(){
  if(!pc) setupPC();
  if(role==='host'){
    const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
    setStatus('Gathering ICE for offer‚Ä¶');
  } else {
    if (!pc.remoteDescription){ setStatus('Set remote offer first', '#ffe57d'); return; }
    const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
    setStatus('Gathering ICE for answer‚Ä¶');
  }
}
async function setRemote(){
  try{
    const raw = $('remote').value.trim();
    if (!raw) { setStatus('Paste peer blob first', '#ffe57d'); return; }
    let desc;
    if (looksLikeJson(raw)) desc = JSON.parse(raw);
    else if (/^[A-Za-z0-9+/=\s]+$/.test(raw) && !looksLikeSdp(raw)) desc = unpackBase64(raw.replace(/\s+/g,''));
    else if (looksLikeSdp(raw)) desc = { type: (role === 'host' ? 'answer' : 'offer'), sdp: raw };
    else throw new Error('Unrecognized blob format');
    if(!pc) setupPC();
    await pc.setRemoteDescription(desc);
    setStatus(`Remote ${desc.type} set`);
  }catch(e){ console.error(e); setStatus('Invalid blob (try Base64 or raw SDP)', '#ff7d7d'); }
}
function send(){
  const text = $('msg').value.trim(); if(!text) return;
  if(!dcChat || dcChat.readyState!=='open'){ setStatus('Not connected (chat DC not open)', '#ffe57d'); return; }
  const name = $('name').value.trim();
  dcChat.send(JSON.stringify({name, text})); addMsg(name||'Me', text, true); $('msg').value='';
}
function resetAll(){
  try{ dcChat&&dcChat.close(); }catch{} try{ dcBJ&&dcBJ.close(); }catch{} try{ pc&&pc.close(); }catch{}
  pc=null; dcChat=null; dcBJ=null;
  $('local').value=''; $('remote').value=''; $('chat').innerHTML='';
  enableChat(false);
  pill($('pcState'),'idle'); pill($('iceState'),'idle'); pill($('dcState'),'chat: idle'); pill($('bjState'),'blackjack: idle');
  setStatus('reset');
  bjResetUI(true);
}

/* ---------- wire up ---------- */
roleInputs.forEach(r=>r.addEventListener('change',()=>{ role=r.value; resetAll(); setupPC(); }));
$('btnCreate').onclick=createLocal;
$('btnSetRemote').onclick=setRemote;
$('btnCopy').onclick=async()=>{
  const t=$('local').value.trim(); if(!t){ setStatus('Nothing to copy','#ffe57d'); return; }
  try{ await navigator.clipboard.writeText(t); setStatus('Copied Base64 ‚úì','#7dff8b'); }catch{ setStatus('Copy failed','#ff7d7d'); }
};
$('btnReset').onclick=resetAll;
$('send').onclick=send;
$('msg').addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); send(); }});

/* ---------- init ---------- */
setupPC(); enableChat(false);
if (location.protocol === 'file:') { setStatus('Tip: use http://localhost or HTTPS (WebRTC may be restricted on file://)', '#ffe57d'); }

/* ==================== Blackjack ==================== */
/* Protocol:
   Dealer clicks "New Hand" ‚Üí send {t:'bj:commit', commit}
   Player clicks "Join Hand" ‚Üí send {t:'bj:client', clientSeedHex}
   Dealer derives deck from (serverSeed, clientSeed) via DRBG + Fisher‚ÄìYates; deals and drives rules
   During/after play ‚Üí at end: Dealer sends {t:'bj:reveal', serverSeedHex}
   Player verifies SHA-256(serverSeed) == commit and recomputes exact deck
*/

// --- helpers (crypto & encoding)
const enc = new TextEncoder();
const dec = new TextDecoder();
const hex = buf => Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
const hexToBytes = (h)=>{ const a=new Uint8Array(h.length/2); for(let i=0;i<a.length;i++) a[i]=parseInt(h.substr(i*2,2),16); return a; };
async function sha256Bytes(bytes){ return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes)); }
async function sha256Hex(bytes){ return hex(await crypto.subtle.digest('SHA-256', bytes)); }
function rand32(n=32){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }

// Deterministic RNG from seeds: K = SHA256(serverSeed || clientSeed); blocks = SHA256(K || counter)
function makeDRBG(serverSeedBytes, clientSeedBytes){
  let counter = 0;
  let pool = new Uint8Array(0);
  let K; // Uint8Array
  return {
    async init(){
      const concat = new Uint8Array(serverSeedBytes.length + clientSeedBytes.length);
      concat.set(serverSeedBytes,0); concat.set(clientSeedBytes,serverSeedBytes.length);
      K = await sha256Bytes(concat);
    },
    async nextBlock(){
      const ctr = new Uint8Array(4); new DataView(ctr.buffer).setUint32(0, counter++, false);
      const m = new Uint8Array(K.length + ctr.length);
      m.set(K,0); m.set(ctr,K.length);
      return await sha256Bytes(m);
    },
    async nextU32(){
      if (pool.length < 4){ const b = await this.nextBlock(); const tmp = new Uint8Array(pool.length + b.length); tmp.set(pool,0); tmp.set(b,pool.length); pool = tmp; }
      const out = new DataView(pool.buffer, pool.byteOffset, pool.byteLength).getUint32(0, false);
      pool = pool.slice(4);
      return out >>> 0;
    }
  };
}

// Unbiased Fisher‚ÄìYates using rejection sampling on nextU32()
async function shuffleDeck(drbg, n=52){
  const deck = Array.from({length:n}, (_,i)=>i);
  for(let i=n-1;i>0;i--){
    // pick j in [0..i] without modulo bias
    const range = i+1;
    const limit = 0x100000000 - (0x100000000 % range);
    let r;
    do { r = await drbg.nextU32(); } while (r >= limit);
    const j = r % range;
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

// Cards & scoring
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
function cardStr(c){ const r = c % 13, s = Math.floor(c/13); return `${RANKS[r]}${SUITS[s]}`; }
function handValue(cards){
  // Aces can be 11 or 1
  let total = 0, aces = 0;
  for(const c of cards){
    const r = c % 13;
    if (r===0){ total += 11; aces++; }        // Ace
    else if (r>=10){ total += 10; }           // J,Q,K
    else total += (r+1);                      // 2..10
  }
  while(total>21 && aces>0){ total -= 10; aces--; }
  return total;
}

// UI helpers for blackjack
function renderHand(el, cards, hideFirst=false){
  el.innerHTML='';
  cards.forEach((c,i)=>{
    const tag=document.createElement('span'); tag.className='cardtag mono';
    tag.textContent = (hideFirst && i===0) ? 'üÇ†' : cardStr(c);
    el.appendChild(tag);
  });
}
function bjSet(txt){ $('bjStatus').textContent = txt; }
function bjResetUI(silent){
  $('bjDealer').innerHTML=''; $('bjPlayer').innerHTML='';
  $('bjDealerVal').textContent=''; $('bjPlayerVal').textContent='';
  $('bjCommit').textContent='‚Äì'; $('bjRevealOut').textContent='‚Äì'; $('bjClientSeed').textContent='‚Äì';
  $('bjFair').textContent='‚Äì';
  $('bjHit').disabled=true; $('bjStand').disabled=true; $('bjReveal').disabled=true;
  $('bjNew').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='host';
  $('bjJoin').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='peer';
  if (!silent) bjSet('');
}

/* Hand state (lives on Dealer; Player mirrors via messages) */
let bj = {
  phase: 'idle',          // 'idle' | 'commit' | 'awaitClient' | 'dealing' | 'playing' | 'done'
  serverSeed: null,       // Uint8Array(32)
  serverCommit: null,     // hex string
  clientSeed: null,       // Uint8Array(32)
  deck: [],               // array of 0..51
  ptr: 0,
  D: [], P: []
};

function nextCard(){ return bj.deck[bj.ptr++]; }

async function dealerNewHand(){
  if (!dcBJ || dcBJ.readyState!=='open'){ bjSet('Blackjack channel not open'); return; }
  bj = {phase:'commit', serverSeed: rand32(32), serverCommit:null, clientSeed:null, deck:[], ptr:0, D:[], P:[]};
  bj.serverCommit = await sha256Hex(bj.serverSeed);
  $('bjCommit').textContent = bj.serverCommit;
  dcBJ.send(JSON.stringify({t:'bj:commit', commit: bj.serverCommit}));
  bj.phase = 'awaitClient';
  $('bjReveal').disabled = false; // allow force reveal if needed
  bjSet('Commit sent. Waiting for player to Join Hand‚Ä¶');
}

async function dealerAfterClientSeed(){
  // derive deck
  const drbg = makeDRBG(bj.serverSeed, bj.clientSeed);
  await drbg.init();
  bj.deck = await shuffleDeck(drbg, 52);
  bj.ptr = 0; bj.D=[]; bj.P=[];
  // initial deal: P, D, P, D
  bj.P.push(nextCard()); bj.D.push(nextCard()); bj.P.push(nextCard()); bj.D.push(nextCard());
  bj.phase = 'playing';
  // send visible info to player
  dcBJ.send(JSON.stringify({t:'bj:start', upcard: bj.D[1], player: bj.P.slice()})); // D[0] face-down
  // render locally (Dealer sees all)
  renderHand($('bjDealer'), bj.D, false);
  renderHand($('bjPlayer'), bj.P, false);
  $('bjDealerVal').textContent = `(${handValue(bj.D)})`;
  $('bjPlayerVal').textContent = `(${handValue(bj.P)})`;
  $('bjHit').disabled = true; $('bjStand').disabled = true;
  bjSet('Dealt. Waiting for player action‚Ä¶');
}

function dealerApplyRulesAndFinish(){
  // Dealer auto-plays to 17+
  while(handValue(bj.D) < 17){ bj.D.push(nextCard()); dcBJ.send(JSON.stringify({t:'bj:dealerDraw', card: bj.D[bj.D.length-1]})); }
  const vP = handValue(bj.P), vD = handValue(bj.D);
  let outcome='push';
  if (vP>21) outcome='dealer';
  else if (vD>21) outcome='player';
  else if (vP>vD) outcome='player';
  else if (vD>vP) outcome='dealer';
  dcBJ.send(JSON.stringify({t:'bj:result', outcome, dealer: bj.D.slice()}));
  // reveal for verification
  dcBJ.send(JSON.stringify({t:'bj:reveal', serverSeed: hex(bj.serverSeed)}));
  $('bjRevealOut').textContent = hex(bj.serverSeed);
  bj.phase='done';
  // update UI
  renderHand($('bjDealer'), bj.D, false);
  $('bjDealerVal').textContent = `(${handValue(bj.D)})`;
  $('bjHit').disabled=true; $('bjStand').disabled=true;
  bjSet(`Result: ${outcome.toUpperCase()}. Server seed revealed; player can verify.`);
}

/* Player-side verification */
async function playerVerify(serverSeedHex, commitHex, clientSeedHex){
  // check commit
  const ss = hexToBytes(serverSeedHex);
  const ccalc = await sha256Hex(ss);
  const commitOK = (ccalc === commitHex);
  // recompute deck
  const drbg = makeDRBG(ss, hexToBytes(clientSeedHex));
  await drbg.init();
  const deck = await shuffleDeck(drbg, 52);
  // Verify that the seen cards match the prefixes we observed:
  // We tracked P and upcard + later dealer revealed full D. We‚Äôll check by replaying dealing order:
  // order: P0, D0, P1, D1, then hits for P, then dealer draws.
  // For a robust check in this demo, we keep a log of dealt sequence we received.
  const ok = commitOK && JSON.stringify(deck.slice(0, bjSeen.order.length)) === JSON.stringify(bjSeen.order);
  $('bjFair').textContent = ok ? '‚úÖ Verified: commit matches and deck order reproduced' :
                                 '‚ùå Mismatch: commit or deck order incorrect';
  return ok;
}

/* Player-side seen sequence tracker */
const bjSeen = { order: [], reset(){ this.order=[]; } };

/* Blackjack channel wire-up */
function wireBJ(ch){
  pill($('bjState'),'blackjack: connecting','warn');
  const updateButtons = ()=>{
    $('bjNew').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='host';
    $('bjJoin').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='peer';
  };

  ch.onopen = ()=>{
    pill($('bjState'),'blackjack: open','ok');
    updateButtons();
    $('bjHit').disabled = true; $('bjStand').disabled = true; $('bjReveal').disabled = (role!=='host');
    bjSet(role==='host' ? 'Click New Hand to start.' : 'Click Join Hand to enter the hand.');
  };
  ch.onclose = ()=>{ pill($('bjState'),'blackjack: closed','bad'); bjResetUI(true); };
  ch.onerror = e=>{ pill($('bjState'),'blackjack: error','bad'); console.error('Blackjack DC error', e); };

  ch.onmessage = async (ev)=>{
    let m; try{ m = JSON.parse(ev.data); }catch{ return; }
    switch(m.t){
      case 'bj:commit': { // Player receives dealer commit
        $('bjCommit').textContent = m.commit;
        bjSet('Dealer committed. Click Join Hand to send your seed.');
        break;
      }
      case 'bj:client': { // Dealer receives client seed
        if (role==='host'){
          bj.clientSeed = hexToBytes(m.client);
          $('bjClientSeed').textContent = m.client;
          dealerAfterClientSeed();
        }
        break;
      }
      case 'bj:start': { // Player receives initial deal
        bjSeen.reset();
        // reconstruct dealing order so far: P0, D0(hidden), P1, D1(upcard)
        bjSeen.order.push(m.player[0], /*D0 unknown*/ null, m.player[1], m.upcard);
        // We can't know D0 yet; we will fill it when dealer reveals
        renderHand($('bjDealer'), [0,m.upcard], true); // show face-down + upcard
        renderHand($('bjPlayer'), m.player, false);
        $('bjPlayerVal').textContent = `(${handValue(m.player)})`;
        $('bjHit').disabled=false; $('bjStand').disabled=false;
        bjSet('Your turn: Hit or Stand.');
        break;
      }
      case 'bj:deal': { // Player gets a new card
        bjSeen.order.push(m.card);
        // append to player hand UI
        const cur = Array.from($('bjPlayer').querySelectorAll('.cardtag')).length;
        const tag=document.createElement('span'); tag.className='cardtag mono'; tag.textContent=cardStr(m.card);
        $('bjPlayer').appendChild(tag);
        $('bjPlayerVal').textContent = `(${m.val})`;
        if (m.val>21){ $('bjHit').disabled=true; $('bjStand').disabled=true; bjSet('Bust! Waiting for dealer‚Ä¶'); }
        break;
      }
      case 'bj:dealerDraw': { // Player watches dealer draw
        bjSeen.order.push(m.card);
        // add to dealer UI after upcard
        const tag=document.createElement('span'); tag.className='cardtag mono'; tag.textContent=cardStr(m.card);
        $('bjDealer').appendChild(tag);
        break;
      }
      case 'bj:result': { // outcome + reveal dealer full hand
        // fill hidden D0 into bjSeen.order at index 1 if provided
        if (m.dealer && m.dealer.length>=2){
          // at this point we know D0; set UI
          $('bjDealer').innerHTML='';
          renderHand($('bjDealer'), m.dealer, false);
          $('bjDealerVal').textContent = `(${handValue(m.dealer)})`;
          if (bjSeen.order.length>=2 && bjSeen.order[1]===null) bjSeen.order[1]=m.dealer[0];
        }
        bjSet(`Result: ${m.outcome.toUpperCase()}. Awaiting reveal for verification‚Ä¶`);
        break;
      }
      case 'bj:reveal': { // Player verifies fairness
        $('bjRevealOut').textContent = m.serverSeed;
        const ok = await playerVerify(m.serverSeed, $('bjCommit').textContent.trim(), $('bjClientSeed').textContent.trim());
        bjSet(ok ? 'Verified. Play again?' : 'Verification failed.');
        $('bjHit').disabled=true; $('bjStand').disabled=true;
        break;
      }
      case 'bj:forceReveal': {
        // Dealer forced a reveal (edge-case); Player verifies anyway
        $('bjRevealOut').textContent = m.serverSeed;
        const ok2 = await playerVerify(m.serverSeed, $('bjCommit').textContent.trim(), $('bjClientSeed').textContent.trim());
        $('bjFair').textContent = ok2 ? '‚úÖ Forced reveal verified' : '‚ùå Forced reveal mismatch';
        bjSet(ok2 ? 'Forced reveal OK.' : 'Forced reveal failed.');
        break;
      }
    }
  };

  // UI buttons
  $('bjNew').onclick = dealerNewHand;
  $('bjJoin').onclick = ()=>{
    if (role!=='peer'){ bjSet('Only the Player can join.'); return; }
    if (!dcBJ || dcBJ.readyState!=='open'){ bjSet('Channel not open'); return; }
    const clientSeed = rand32(32);
    const hexSeed = hex(clientSeed);
    $('bjClientSeed').textContent = hexSeed;
    dcBJ.send(JSON.stringify({t:'bj:client', client: hexSeed}));
    bjSet('Sent client seed. Waiting for deal‚Ä¶');
  };
  $('bjHit').onclick = ()=>{
    if (role!=='peer' || !dcBJ || dcBJ.readyState!=='open') return;
    dcBJ.send(JSON.stringify({t:'bj:action', a:'hit'}));
  };
  $('bjStand').onclick = ()=>{
    if (role!=='peer' || !dcBJ || dcBJ.readyState!=='open') return;
    dcBJ.send(JSON.stringify({t:'bj:action', a:'stand'}));
    $('bjHit').disabled=true; $('bjStand').disabled=true;
  };
  $('bjReveal').onclick = ()=>{
    if (role!=='host' || !bj.serverSeed) return;
    dcBJ.send(JSON.stringify({t:'bj:reveal', serverSeed: hex(bj.serverSeed)}));
    $('bjRevealOut').textContent = hex(bj.serverSeed);
  };

  // Dealer handles actions from player
  ch.addEventListener('message', (ev)=>{
    let m; try{ m=JSON.parse(ev.data); }catch{ return; }
    if (role!=='host') return;
    if (m.t==='bj:action' && bj.phase==='playing'){
      if (m.a==='hit'){
        const c = nextCard(); bj.P.push(c);
        dcBJ.send(JSON.stringify({t:'bj:deal', card:c, val:handValue(bj.P)}));
        // Update dealer UI too
        const tag=document.createElement('span'); tag.className='cardtag mono'; tag.textContent=cardStr(c);
        $('bjPlayer').appendChild(tag); $('bjPlayerVal').textContent = `(${handValue(bj.P)})`;
        if (handValue(bj.P)>21){ // bust
          dealerApplyRulesAndFinish();
        }
      } else if (m.a==='stand'){
        dealerApplyRulesAndFinish();
      }
    }
  });
}

/* enable/disable game controls depending on channel */
(function gateButtons(){
  const refresh = ()=>{
    $('bjNew').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='host';
    $('bjJoin').disabled = !dcBJ || dcBJ.readyState!=='open' || role!=='peer';
  };
  setInterval(refresh, 500);
})();
</script>
</body>
</html>
